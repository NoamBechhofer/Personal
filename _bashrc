# ~/.bashrc: executed by bash(1) for non-login shells.
# see /usr/share/doc/bash/examples/startup-files (in the package bash-doc)
# for examples

# If not running interactively, don't do anything
case $- in
*i*) ;;
*)
    if [[ "${BASH_SOURCE[0]}" != "${0}" ]]; then
        # Script is sourced, use return
        return
    else
        # Script is executed, use exit
        exit
    fi
    ;;
esac

# don't put duplicate lines or lines starting with space in the history.
# See bash(1) for more options
HISTCONTROL=erasedups

# append to the history file, don't overwrite it
shopt -s histappend

# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
HISTSIZE=1000
HISTFILESIZE=2000

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

# make `less` more friendly for non-text input files, see lesspipe(1)
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

# set variable identifying the chroot you work in (used in the prompt below)
if [ -z "${debian_chroot:-}" ] && [ -r /etc/debian_chroot ]; then
    debian_chroot=$(cat /etc/debian_chroot)
fi

# set a fancy prompt (non-color, unless we know we "want" color)
case "$TERM" in
xterm-color | *-256color) color_prompt=yes ;;
esac

# uncomment for a colored prompt, if the terminal has the capability
force_color_prompt=yes

if [ -n "$force_color_prompt" ]; then
    if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
        # We have color support; assume it's compliant with Ecma-48
        # (ISO/IEC-6429). (Lack of such support is extremely rare, and such
        # a case would tend to support setf rather than setaf.)
        color_prompt=yes
    else
        color_prompt=
    fi
fi

parse_git_branch() {
    git branch 2>/dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/ (\1)/' -e 's/^[[:space:]]*//' -e 's/.*/& /'
}

if [ "$color_prompt" = yes ]; then
    # tell python not to prepend venv names to PS1, since we'll handle that ourselves...
    export VIRTUAL_ENV_DISABLE_PROMPT=1
    # ... and then do it ourselves
    PS1='$(if [[ -n "${VIRTUAL_ENV}" ]]; then `
    `echo "\[\033[01;31m\]$(basename "$(echo "$VIRTUAL_ENV")") \[\033[00m\]"; \
    fi)`
    `${debian_chroot:+($debian_chroot)}`
    # basic u@h:w
    `\[\033[01;32m\]\u@\h\[\033[00m\]`
    `:`
    `\[\033[01;34m\]\w\[\033[00m\]`
    # list the operating system
    `\[\033[01;35m\] $(uname -o) \[\033[00m\]`
    `\n`
    # git branch
    `\[\033[01;33m\]$(echo "$(parse_git_branch)")\[\033[00m\]'
else
    # basic u@h:w + git branch
    PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w $(uname -o) $(parse_git_branch)'
fi
# add the dollar sign prompt
PS1+="\$ "

# If this is an xterm set the title to user@host:dir
case "$TERM" in
xterm* | rxvt*)
    PS1="\[\e]0;${debian_chroot:+($debian_chroot)}\u@\h: \w\a\]$PS1"
    ;;
*) ;;
esac

# enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'
    #alias dir='dir --color=auto'
    #alias vdir='vdir --color=auto'

    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi

# colored GCC warnings and errors
#export GCC_COLORS='error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01'

# some more ls aliases
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'

# Add an "alert" alias for long running commands.  Use like so:
#   sleep 10; alert
alias alert='notify-send --urgency=low -i "$([ $? = 0 ] && echo terminal || echo error)" "$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&|]\s*alert$//'\'')"'

# Alias definitions.
# You may want to put all your additions into a separate file like
# ~/.bash_aliases, instead of adding them here directly.
# See /usr/share/doc/bash-doc/examples in the bash-doc package.

if [ -f ~/.bash_aliases ]; then
    . ~/.bash_aliases
fi

# enable programmable completion features (you don't need to enable
# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
# sources /etc/bash.bashrc).
if ! shopt -oq posix; then
    if [ -f /usr/share/bash-completion/bash_completion ]; then
        . /usr/share/bash-completion/bash_completion
    elif [ -f /etc/bash_completion ]; then
        . /etc/bash_completion
    fi
fi

umask 077
export EDITOR=vim

# my favorite things I would like to do if I am running in Windows
if [[ "$OSTYPE" == "msys" ]]; then # msys is git bash
    # enable git bash to automatically pull the path from windows
    pathAliasDir="$(pwd)"
    cd ~
    [ -f ./UpdatePath.sh ] || {
      cat <<'EOF' > ./UpdatePath.sh
#!/bin/bash
updatePathWorkingDir=$(pwd)
cd $HOME

# This script updates the git bash $PATH to match the user's %PATH%
# First, add the following line to your .bashrc:
# alias path='pathAliasDir=$(pwd) && cd ~ && ./UpdatePath.sh && export PATH=`cat PATH` && rm PATH && cd $pathAliasDir && unset pathAliasDir && alias path="echo \"can only update path once per bash session\""'
# Now you can always call this script by just using the command "path"

# It's hard to get %PATH% from within git bash. Let's call this powershell script which does it for us.
# first make sure the script exists
if ! [ -f $HOME/GetWindowsPath.ps1 ]; then
    cat <<-'PS1' >$HOME/GetWindowsPath.ps1
# split the path into an array of seperate filepaths
$currPath = $env:path -split ';'

# bashify each filepath
for (($i = 0); $i -lt $currPath.Length; $i++) {
    if ($currPath[$i].EndsWith("\")) {
        $currPath[$i] = $currPath[$i].Substring(0, $currPath[$i].Length - 1)
    }

    $currPath[$i] = (($currPath[$i] -replace '\\', '/') -replace 'C:', '/c') + ":"
}

# now we'll write the array to a file
$pathFilePath = $HOME + "\WINPATH"
Set-Content -Path $pathFilePath -value $currPath
PS1
fi
# ok if it didn't exist, it exists now. Let's execute it with powershell
powershell -ExecutionPolicy Bypass -File $HOME/GetWindowsPath.ps1

# now we need the bash path. Again, split it such that each filepath is on its own line and write it to a file.
echo $PATH | sed 's#/:#:#g' | sed 's#:#:\n#g' >$HOME/BASHPATH

# Ok, now in our $HOME directory we have a WINPATH and a BASHPATH file.
# In both of these, each filepath is on its own line.
# So we need to merge these two lists.
# We'll use this Java program to do it:
# again, first we make sure the java program exists. If not, we'll write it and compile it
if ! [ -f $HOME/UpdatePath.class ]; then
    cat <<-'JAVA' >$HOME/UpdatePath.java
import java.io.File;
import java.io.FileNotFoundException;
import java.util.HashSet;
import java.util.Scanner;

public class UpdatePath {
    public static void main(String[] args) throws FileNotFoundException {

        String homeDir = System.getProperty("user.home");

        File winPath = new File(homeDir + "\\WINPATH");
        File bashPath = new File(homeDir + "\\BASHPATH");

        HashSet<String> hash = new HashSet<>();

        Scanner bashScanner = new Scanner(bashPath);
        while (bashScanner.hasNextLine())
            hash.add(bashScanner.nextLine());

        bashScanner.close();

        Scanner winScanner = new Scanner(winPath);
        while (winScanner.hasNextLine())
            hash.add(winScanner.nextLine());

        winScanner.close();

        String PATH = "";
        for (String s : hash)
            PATH += s;

        System.out.println(PATH);
    }
}
JAVA
    javac UpdatePath.java
    rm UpdatePath.java
fi
# ok now run the program
java UpdatePath >$HOME/PATH

# ok these files are no longer necessary, delete them
rm $HOME/WINPATH $HOME/BASHPATH

# done! the alias'd `path` command will delete the remaining $HOME/PATH once it's finished with it

cd $updatePathWorkingDir

# bonus: break down of the `path' alias
# The full alias reads:
# alias path='
#   pathAliasDir=$(pwd) &&                                              ## save the directory we're at so we can return to it
#   cd ~ &&                                                             ## move to the home directory
#   ./UpdatePath.sh &&                                                  ## run the script
#   export PATH=`cat PATH` &&                                           ## set the $PATH to the PATH file that the script generated
#   rm PATH &&                                                          ## Ok since it's set we can delete the file
#   cd $pathAliasDir &&                                                 ## Ok we're done so return to the directory we started at...
#   unset pathAliasDir &&                                               ## and we don't have to keep track of the directory anymore
#   alias path="echo \"can only update path once per bash session\""    ## now we need to make sure the alias isn't called again as that may cause bugs, so we redefine the alias
# '
EOF
      chmod +x ./UpdatePath.sh
    }
    ./UpdatePath.sh
    export PATH=$(cat PATH)
    rm PATH
    cd "$pathAliasDir"
    unset pathAliasDir
    if [ "$color_prompt" = yes ]; then
        echo -e "\033[01;34mpulled \$PATH from %PATH%\033[01;33m"
    else
        echo "pulled \$PATH from %PATH%"
    fi

    # use vim from windows
    export EDITOR="/c/Windows/vim.bat"
else # not windows, so assume UNIX
    # use vim from unix
    export EDITOR=/usr/bin/vim
fi
git config --global core.editor $EDITOR

mkcd() {
    mkdir "$1"
    cd "$1"
}

unset color_prompt force_color_prompt

c() {
    command pushd "$@" >/dev/null
}

p() {
    command popd "$@" >/dev/null
}

# option for adding local bash configs:
# write a file ~/.bashrc_local and add your local configs there
if [ -f ~/.bashrc_local ]; then
    . ~/.bashrc_local
fi
